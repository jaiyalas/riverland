% !TEX TS-program = xelatex
% \documentclass[a4paper]{article}
\documentclass[a4paper,twocolumn]{article}

\usepackage{bussproofs}
\usepackage{amssymb}
\usepackage[colorlinks=true]{hyperref}

\title{Reversibility, computation and language}
\author{Jen-Shin Lin}

\begin{document}

\maketitle

Linear logic \cite{Girard95}, firstly developed in classical sequent calculus, features that: \textit{any information (truth) cannot be created or discarded arbitrarily}. It also provides an explicit way to formally describe temporal and spatial resources. To see that, as mentioned in Novitzk\'{a}'s work \cite{Novitzka07}, linear logic can realize both of positive and negative data types due to its lack of two important structural rules: \textit{contraction} and \textit{weakening}.

From Curryâ€“Howard correspondence, we know that there must be a type system for linear logic that can format the usage of resources and even the information-flow. This give us an inspiration: it may be possible to use linear type for modeling information-flow, and with that one can determine a trace of computation which can show us how to compute backwards. The rest of this article will show how to develop a type system from linear logic and what those type systems can do and is that possible to develop a reversible langauage from it.

\subsection*{Reversible communication}

Starting by directly creating typing rules from linear logic, immediately we hit a wall: we don't know how to assign term(s) to those rules. For example, what a $\lambda$-term will be for the following rule?

\begin{prooftree}
\AxiomC{$\vdash \Gamma , A$}
\AxiomC{$\vdash \Delta , B$}
\RightLabel{($\otimes$-I)}
\BinaryInfC{$\vdash \Gamma , \Delta , A \otimes B$}
\end{prooftree}

The thing is, in classical sequent calculus, there may be more than one consequent on the right-hand-side of a judgment. This is not a scenario that $\lambda$-calculus can fit or apply, but, \textit{$\pi$-calculus} do. The type system developed directly from classical linear logic is known as \textit{session type} \cite{Wadler12}. It have the capability to describe the flow of information or resources involved within the communication between two or even more processes. Obviously this can be used to model distributed system or parallelism.

In distributed system, reversibility leads to a very practical topic named {\textit{reversible distributed system}}. Reversible distributed system have the ability to abort and unwind a computation with states recovery. Brown and Sabry \cite{Brown16} have developed a reversible process language with a high-level semantics. This topic and works look very valuable however it is more like a language for reversible communication rather reversible computation. This is not exactly what we were looking for.

\subsection*{Reversible language}

As discussed above, the idea of creatnig a type system directly from linear logic turns out not be able to solve our problem. So let's try the conventional method. As plenty works have done \cite{Benton92, Wadler93, Benton93, Ronchi94, Turner98}, it actually not hard to rewrite \textit{classical} linear logic rules into \textit{intuitionistic} one, and the type system we want will reveal itself instantly. This type system is called as \textit{linear type} and it is not too hard to give it a term assigment which will be an extension of $\lambda$-calculus.

With the understanding of linear type, lots of researchers put efforts into finding a way to define a well-form reversible programming language. Yokoyama, Axelsen and Gl\"{u}ck have developed a reversible functional language based on the technique of pattern maching \cite{Yokoyama11}. Recently they have also developed a reversible imparetive programming language with reversible flowcharts \cite{Yokoyama16}. Spark and Sabry \cite{Sparks14}, on the other hand, have not used the conventional way. They have developed another logic system from linear logic and discarded some properties those are not helpful for reversible programming. This logic is called reversible logic and they have also defined a simple reversible language, $\Lambda^{R}$ , for it.

% \cite{James12}
%    Information Effects
% \cite{James13}
%    Isomorphic Interpreters from Logically Reversible Abstract Machines
% \cite{James14}
%    Theseus: A high level language for reversible computing

\paragraph{Conclusion}
Our goal is to build a reversible functional language. Our original intuition was, linear type could somehow useful and we might be able to discover a reversible type by directly manipulating linear type. In the end, it looks not that simple as we expected. Linear logic give too much power to describe data structures, like the capability to seperate positive and negative types, which is not necessary for reversible computation. The point will be, firstly find some necessary operators and properties from linear type or logic; and secondly, how to use those operators and properties to record or generate a computation path that can directly show us how to compute backwards. Besides finding some new ways to provide reversibility of functional language, there are still several problem waiting us to overcome. For example, recent works were more focusing on providing reversibility via syntax and semantics. which is great. But less works put efforts on applying type system to verify the correctness for reversibility. 

% \begin{prooftree}
% \AxiomC{$\Gamma \vdash A$}
% \AxiomC{$B, \Delta \vdash C$}
% \RightLabel{($\multimap$-L)}
% \BinaryInfC{$\Gamma, A \multimap B, \Delta \vdash C$}
% \end{prooftree}
% \begin{prooftree}
% \AxiomC{$\Gamma, A \vdash B$}
% \RightLabel{($\multimap$-R)}
% \UnaryInfC{$\Gamma \vdash A \multimap B$}
% \end{prooftree}


\bibliographystyle{acm}
\bibliography{ref}

\end{document}
