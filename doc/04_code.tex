\section*{Appendix: Source code}
\subsubsection*{Expr.hs}
\begin{framed}
\begin{code}
    module Expr where
    --
    type FName   = String
    type FunName = String
    --
    data Nat = Z | S Nat deriving (Show, Eq)

    int2nat :: Int -> Nat
    int2nat 0 = Z
    int2nat n = S $ int2nat (n-1)
    nat2int :: Nat -> Int
    nat2int Z = 0
    nat2int (S n) = 1 + (nat2int n)
    --
    data Val     = Pair Val Val
                 | N Nat
                 | B Bool
                 deriving (Show, Eq)
    --
    redN :: Val -> Val
    redN (N (S n)) = N n
    --
    data Mat     = Mat FName
                 deriving (Show, Eq)
    data Var     = Var FName
                 deriving (Show, Eq)
    --
    data Term a  = Lit Val
                 | Atom a
                 | Prod (Term a) (Term a)
                 | Fst  (Term a)
                 | Snd  (Term a)
                 --
                 | NatS (Term a)
                 deriving (Show, Eq)
    --
    type MTerm   = Term Mat
    type VTerm   = Term Var
    --
    mat :: FName -> MTerm
    mat = Atom . Mat
    var :: FName -> VTerm
    var = Atom . Var
    --
    -- call-by-name function application
    type FApp    = (FunName, [VTerm])
    --
    data Case    = (:->) {uncasePatt :: MTerm, uncaseExpr :: Expr}
                 deriving (Show, Eq)
    --
    data Expr    = Term VTerm
                 | LetIn MTerm (Either VTerm FApp) Expr
                 | DupIn MTerm VTerm Expr
                 | Match VTerm [Case]
                 | MatEq (VTerm, VTerm) Case Case
                 deriving (Show, Eq)
\end{code}
\end{framed}
%% == %% == %% == %% == %% == %% == %% == %% == %%
%% == %% == %% == %% == %% == %% == %% == %% == %%
%% == %% == %% == %% == %% == %% == %% == %% == %%
\subsubsection*{Func.hs}
\begin{framed}
\begin{code}
    module Func where
    --
    import Expr
    --
    type FSpace = [FSpec]
    data FSpec = FSpec { fname :: FunName
                       , fargs :: [Mat]
                       , fbody :: Expr
                       }
               deriving (Show, Eq)
    --
    findFun :: FunName -> FSpace -> FSpec
    findFun fn [] = error $ "there is no such function: " ++ fn
    findFun fn (fs:fss)
        | fn == fname fs = fs
        | otherwise = findFun fn fss
    --
    globalFuns :: FSpace
    globalFuns =
           [ FSpec "succ" [Mat "#0"] succExpr
           , FSpec "plus" [Mat "#0", Mat "#1"] plusExpr
           , FSpec "plusR" [Mat "#0"] plusRExpr
           , FSpec "neg" [Mat "#0"] negExpr
           , FSpec "and" [Mat "#0", Mat "#1"] andExpr
           ]
    --
    succExpr :: Expr
    succExpr =
        Match (var "#0")
            [ (Lit $ N Z)  :->
                (Term $ Lit $ N (S Z))
            , (NatS $ mat "u") :->
                LetIn (mat "u2")
                    (Right ("succ", [var "u"]))
                    (Term $ NatS $ var "u2")
            ]
    plusExpr :: Expr
    plusExpr =
        Match (var "#1")
            [ (Lit (N Z))  :->
                DupIn (Prod (mat "a") (mat "b")) (var "#0")
                    (Term $ Prod (var "a") (var "b"))
            , (NatS $ mat "u") :->
                LetIn (Prod (mat "x2") (mat "u2"))
                    (Right ("plus", [var "#0", var "u"]))
                    (Term $ Prod (var "x2") (NatS $ var "u2"))
            ]
    plusRExpr :: Expr
    plusRExpr = LetIn (Prod (mat "#0_a") (mat "#0_b"))
        (Left $ var "#0") $
            MatEq (var "#0_a", var "#0_b")
                ((mat "x")  :-> (Term $ Prod (var "x") (Lit $ N Z)))
                ((Prod (mat "x") (NatS (mat "u"))) :->
                    (LetIn (Prod (mat "x2") (mat "u2"))
                        (Right ("plusR", [Prod (var "x") (var "u")]))
                        (Term $ Prod (var "x2") (NatS $ var "u2"))))
    negExpr :: Expr
    negExpr =
        Match (var "#0")
            [ (Lit (B True))  :->
                (Term $ Lit $ B False)
            , (Lit (B False)) :->
                (Term $ Lit $ B True)
            ]
    andExpr :: Expr
    andExpr = undefined
\end{code}
\end{framed}
%% == %% == %% == %% == %% == %% == %% == %% == %%
%% == %% == %% == %% == %% == %% == %% == %% == %%
%% == %% == %% == %% == %% == %% == %% == %% == %%
\subsubsection*{Ctx.hs}
\begin{framed}
\begin{code}
    module Ctx where
    --
    import Expr
    --
    type Env = [(Var, Val)]
    --
    find :: Var -> Env -> (Val, Env)
    find va [] = error $ "there is no such variable" ++ (show va)
    find v1 ((v2, val) : env)
        | v1 == v2 = (val, env)
        | otherwise = let (val2, env2) = find v1 env
            in (val2, (v2, val) : env2)
    --
    appSigma :: Env -> VTerm -> (Val, Env)
    appSigma env (Lit val) = (val, env)
    appSigma env (Atom va) = find va env
    appSigma env (Prod vt1 vt2) =
        let (val1, env1) = appSigma env vt1
            (val2, env2) = appSigma env1 vt2
        in (Pair val1 val2, env2)
    appSigma env (Fst  vt) = appSigma env vt
    appSigma env (Snd  vt) = appSigma env vt
    appSigma env (NatS vt) =
        let (N nat, env1) = appSigma env vt
        in (N $ S nat, env1)
    --
    appSigmaList :: Env -> [VTerm] -> [Val] -> ([Val], Env)
    appSigmaList env [] vs = (reverse vs, env)
    appSigmaList env (vt : vts) vs =
        let (val, env') = appSigma env vt
        in appSigmaList env' vts (val : vs)
    --
    zipMatEnv :: MTerm -> Val -> Env -> Env
    zipMatEnv (NatS mt) (N (S nat)) env = zipMatEnv mt (N nat) env
    zipMatEnv (Prod mt1 mt2) (Pair v1 v2) env =
        zipMatEnv mt2 v2 $ zipMatEnv mt1 v1 $ env
    -- zipMatEnv (Atom (Mat name)) (N n) env = (Var name, N n) : env
    -- zipMatEnv (Atom (Mat name)) (B b) env = (Var name, B b) : env
    -- zipMatEnv (Atom (Mat name)) (Pair v1 v2) env =
        -- (Var name, Pair v1 v2) : env
    -- these three are identical, merged as follow
    zipMatEnv (Atom (Mat name)) v env = (Var name, v) : env
    zipMatEnv mt v env = error $ "\n\tMT{"++(show mt)
        ++ "} \n\tVal{"++(show v)++"} \n\tEnv{"++(show env)++"}"
    --
    zipMatEnvC :: (MTerm, Val) -> Env -> Env
    zipMatEnvC (m, v) e = zipMatEnv m v e
\end{code}
\end{framed}
%% == %% == %% == %% == %% == %% == %% == %% == %%
%% == %% == %% == %% == %% == %% == %% == %% == %%
%% == %% == %% == %% == %% == %% == %% == %% == %%
\subsubsection*{RedB.hs}
\begin{framed}
\begin{code}
    module RedB where
    --
    import Expr
    import Func
    import Subs
    import Ctx
    --
    redBeta :: Env -> Expr -> (Val, Env)
    -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    redBeta env (Term vt) =
        appSigma env vt
    -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    redBeta env (LetIn mt (Left vt) e) =
        let (val, env') = appSigma env vt
            newEnv = zipMatEnv mt val env'
        in redBeta newEnv e
    -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    redBeta env (LetIn mt (Right (fun, vts)) e) =
        let fspec = findFun fun globalFuns
            (vals, env') = appSigmaList env vts []
            res = apply fspec vals
            newEnv = zipMatEnv mt res env'
        in redBeta newEnv e
    -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    -- MTerm in dup will be limited in terms of Prod
    -- VTerm in dup will be limited in terms of Atom
    redBeta env (DupIn (Prod (Atom (Mat ma1)) (Atom (Mat ma2))) (Atom va) e) =
            let (val, env') = find va env
                newEnv = (Var ma2, val) : (Var ma1, val) : env'
            in redBeta newEnv e
    -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    redBeta env (Match vt cases) =
        let (val, env1) = appSigma env vt
            (env2, e) = matching val cases
        in redBeta (env1 ++ env2) e
    -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    redBeta env (MatEq (Atom va1, Atom va2) case1 case2) =
        let (val1, env1) = find va1 env
            (val2, env2) = find va2 env1
        in if val1 == val2
            then case case1 of
                ((Atom (Mat ma)) :-> e1) -> redBeta ((Var ma, val2) : env2) e1
                ((NatS (Atom (Mat ma))) :-> e2) ->
                    redBeta ((Var ma, redN val1) : env2) e2
            else case case2 of
                ((Prod mt1 mt2) :-> e1) ->
                    let newEnv = zipMatEnv mt2 val2 $ zipMatEnv mt1 val1 $ env2
                    in redBeta newEnv e1
    -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    apply :: FSpec -> [Val] -> Val
    apply (FSpec _ args body) vals =
        fst $ redBeta (foldr zipMatEnvC [] $ zip (fmap Atom args) vals) body
        -- we cannot check the equality of length of args and vals here.. :(
    -- -- -- --
    matching :: Val -> [Case] -> (Env, Expr)
    --
    matching (Pair v1 v2) (((Prod mt1 mt2) :-> e) : cs) =
        let env = zipMatEnv mt2 v2 $ zipMatEnv mt1 v1 []
        in (env, e)
    --
    matching (N nat)      (((Lit (N n)) :-> e) : cs)
        | nat == n = ([], e)
        | otherwise = matching (N nat) cs
    --
    matching (N nat)      (((Atom ma) :-> e) : cs) =
        (zipMatEnv (Atom ma) (N nat) [], e)
    --
    matching (N (S nat))  (((NatS mt) :-> e) : cs) =
        maybe (matching (N (S nat)) cs) id $ localMatchingN (N nat) (mt :-> e)
    --
    matching (B b)        (((Lit (B b')) :-> e) : cs)
        | b == b' = ([], e)
        | otherwise = matching (B b) cs
    --
    matching (B b)        (((Atom ma) :-> e) : cs) =
        (zipMatEnv (Atom ma) (B b) [], e)
    --
    matching val (_ : cs) = matching val cs
    matching val [] = error $ "Non-exhaustive patterns for: " ++ (show val)
    -- -- -- --
    localMatchingN :: Val -> Case -> Maybe (Env, Expr)
    localMatchingN (N n) ((Atom (Mat ma)) :-> e) = Just ([(Var ma, N n)], e)
    localMatchingN (N n) ((Lit (N m)) :-> e)
        | n == m = Just ([], e)
        | otherwise = Nothing
    localMatchingN (N (S nat)) ((NatS mt) :-> e) =
        localMatchingN (N nat) (mt :-> e)
    localMatchingN _ _ = Nothing
    --
    test_neg = redBeta [(Var "#0", B False)] negExpr
    test_plus m n = redBeta
        [(Var "#0", N $ int2nat m), (Var "#1", N $ int2nat n)] plusExpr
    test_succ m = redBeta
        [(Var "#0", N $ int2nat m)] succExpr
    test_plusR (m,n) = redBeta
        [(Var "#0", Pair (N $ int2nat m) (N $ int2nat n))] plusRExpr
\end{code}
\end{framed}
