% !TEX TS-program = xelatex
\documentclass[a4paper]{article}
% \documentclass[a4paper,twocolumn]{article}

\usepackage{minted}

\usepackage{bussproofs}
\usepackage{amssymb}
\usepackage[colorlinks=true]{hyperref}
\usepackage[inline]{enumitem}

\newlist{inlinelist}{enumerate*}{1}
\setlist[inlinelist]{label=[\arabic*]}
% \setlist[inlinelist]{label=[\Roman*]}
\newlist{sublist}{enumerate*}{1}
\setlist[sublist]{label=(\roman*)}

\title{River: a functional reversible language}
\author{Jen-Shin Lin}

\begin{document}

\maketitle

From our previous researches and studies, we did get some idea of how can we start we developing on functional reversible language. On the one hand, we confirm that indeed linear logic and linear types cannot be directly applied here. However the way of how it explicitly presents and manages information, variables and their flow is a very helpful guide for us. On the other hand the syntax created from reverible logic lacks some essential mechanism or operator such that it can be use pratically and easily. Therefore we combine several techniques and notions so far we know from
\begin{sublist}
\item linear logic and types and its term-assignment \cite{Benton92, Wadler93, Benton93, Ronchi94, Girard95, Turner98, Novitzka07}
\item previous works on reversibility \cite{Yokoyama11, Sparks14, Brown16, Yokoyama16}
\end{sublist}
, and come up with a new functional language with reversibility, named \textit{river}.



\begin{description}
\item[Pattern calculus] {
    To reveal and monitor the information-flow within a given function, one way to go is to realise two techniques
    \begin{sublist}
    \item precisely describe very variable in environment, which will be explain later; and
    \item apply delicate pattern matching.
    \end{sublist}
    Here we develop our syntax with an explicit structures for \textit{case}s where all the pattern matching will happen. Besides we also seperate \textit{terms} from \textit{expr}. This is helpful to expose \textit{pattern} and making the implementation of pattern matching simpler.
}
\item[Matchable] {
    The simple pattern matching can get most jobs done. But, since we are expecting all behaviors of variable will be captured in our system, we introduced \textit{matchable}s for denoting variables in matching pattern. In general speaking, occurrences of variable indicate consuming exist information from environment and occurrences of matchable indicate introducing new information into environment. Matchables also provides the basical supporting for ensuring and overwatching the linearity of environment.
}
\item[Linear context] {
    To overwatch the information-flow while computing a function, the linear typed programming show us a very good way - we restrict that every variable can be used once and only once. When a function is getting to be evaluated, input values will be put into environment (as variables) then every use of those value (information) will be precisely controlled by variables and matchables. One variable die then one matchable will be borned, vice versa.
}
\end{description}

So far we introduced the theniques we used for enhancing (or, in someway, limiting) the capability of our language. Next we will explain several minor efforts that simply improve the usability of it.

\begin{description}
% \item[Well-designed syntax] ...
\item[Syntactic foundation for dup-eq] .
%% --- %% --- %% --- %% --- %% --- %% --- %% --- %% --- %%

\item[Restricted function declaration] ...
\item[Global function register] ...
%% --- %% --- %% --- %% --- %% --- %% --- %% --- %% --- %%
\item[Operational semantics] ...
\item[Combinator] ...
\end{description}







\paragraph{Conclusion} Finally we have our language with a operational semantics and reversed reduction. The source code can be found in here [\url{https://dl.dropboxusercontent.com/u/11966021/src/River.zip}]. Yet there are still lots of improvement can be done. The following are several possible directions.
\begin{inlinelist}
\item \textit{view-pattern$^{?}$}:
\item \textit{de bruijn index}:
\item \textit{locally nameless}:
\item \textit{hybrid context}:
\item \textit{explicit variables management}:
\end{inlinelist}


\inputminted{haskell}{../haskell/Expr.hs}

\bibliographystyle{acm}
\bibliography{ref}

\end{document}
